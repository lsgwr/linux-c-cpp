# 01 标准IO
> 参考博客：https://www.cnblogs.com/0xcafebabe/p/4423699.html
## 1.标准 IO（STDIO）和系统 IO（SYSIO）的差别

| 类型  | 可移植性 | 实时性 | 吞吐量 | 功能 |
| ----- | -------- | ------ | ------ | ---- |
| STDIO | 高       | 低     | 高     | 受限 |
| SYSIO | 低       | 高     | 低     | 自由 |

这里我一个一个的解释表格中的每一项，表格中的每一项都是两者之间相对而言，使用哪种 IO 并没有绝对的好坏之分，要根据实际的需求来决定应该使用哪个。

### 1.1 可移植性：

标准 IO 是 C89 支持的函数，所以使用了标准 IO 的程序无论在 Linux 平台还是换成了 Windows 平台，不用修改代码是可以直接编译运行的。

而系统 IO 是由内核直接提供的函数库实现的，不同的操作系统平台上提供的 IO 操作接口是不同的，所以想要移植使用了系统 IO 的程序，必须按照目标平台的 IO 库修改程序并重新调试。

所以你写的程序将来可能在不同的平台上运行，那么最好使用标准 IO 库；如果你的程序是专门针对于某个平台而开发的，那么使用系统 IO 库能够得到我们下面说的其它优势。

### 1.2 实时性和吞吐量：

讲这两个概念之前我先给大家看一段代码：

```c
#include <stdio.h>
#include <unistd.h>

int main (void)
{
    putchar('a');
    write(1, "b", 1);

    putchar('a');
    write(1, "b", 1);

    putchar('a');
    write(1, "b", 1);

    printf("\n");

    return 0;
}
```

 

```shell
> $ gcc -Wall 1.c 
> $ ./a.out 
bbbaaa
```

输出的结果为什么不是 ababab 呢，这就是因为**标准IO 具有合并系统调用的功能**，putchar() 将本应该执行多次的 write() 动作合并成了一步来完成，所以 aaa 是作为一个字符串打印的，这一点我们可以通过 strace 命令跟踪系统调用来得出结论(下方第7行)。另外由于 stdout 默认使用的是行缓冲模式(下面会讲缓冲)，所以对 putchar() 的调用并没有立即打印出来。

```shell
>$ strace ./a.out
# ... 此处省略 n 行不相关内容
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f077a35f000
write(1, "b", 1b)                        = 1
write(1, "b", 1b)                        = 1
write(1, "b", 1b)                        = 1
write(1, "aaa\n", 4aaa
)                    = 4
exit_group(0)
```

到这里我们还是没有说明白为什么`标准IO吞吐量高`，而`系统IO实时性高`。我再举个简单的栗子：门卫老大爷负责送信到邮局，他去一次邮局要花费 10 分钟的时间，而每次最多能送 20 封信，每当信件累计到 20 封的时候他就要动身去邮局了。但是当他收到一封加急的邮件时，就会立即去一趟邮局。系统 IO 就好比每收到一封信时都要去一趟邮局，所以实时性高。而标准 IO 就好比要攒够 20 封信才去一趟邮局，所以吞吐量高，因为用户把信件交到老大爷的手上时就会立即返回，响应速度快，用户体验更好。而我们使用 fflush() 之类的函数强制刷新缓冲的时候，就相当于是老大爷收到了一封加急信件需要立即去一趟邮局送信。


### 1.3 功能
至于这里所说的标准IO功能受限，是因为标准IO在各个平台上都是使用系统IO封装的，为了使它具有通用性，又要考虑底层操作系统各自平台在实现上的差异，难免在功能上就要作出让步。

## 2.常用的标准IO函数

首先要了解的一个概念是文件位置指针。

当我们打开一个文件要对它进行读写的时候，我们怎么能知道要从哪里开始读（写）文件呢？其实标准库准备了一个工具辅助我们读写文件，它就是**文件位置指针**。当我们使用标准库函数操作文件的时候，它会自动根据文件位置指针找到我们要操作的位置，也会随着我们的读写操作而自动修改指向，而不用我们自己手动记录和修改文件的操作位置。它使用起来非常方便，以至于你完全感觉不到它的存在，但是为了更好的理解文件 IO，你必须知道它的作用。

### 2.1 fopen()
#### ① 原型
```c
// fopen - stream open functions

#include <stdio.h>

FILE *fopen(const char *path, const char *mode);
```

#### ② 功能
> 在操作文件之前，我们需要通过 fopen() 函数将文件打开，通过这个函数我们可以告诉操作系统我们要操作的是哪个文件，以及用什么样的方式操作这个文件。

#### ③ 参数

+ path：要操作的文件路径。

+ mode：文件的打开方式，这个打开方式一共分为6种。
  + `r`：以**只读**的方式打开文件，并且文件位置指针会被定位到文件首。如果要打开的文件不存在则报错。
  + `r+`：以**读写**的方式打开文件，并且文件位置指针会被定位到文件首。如果要打开的文件不存在则报错。
  + `w`：以**只写**的方式打开文件，如果文件不存在则创建，如果文件已存在则被**截断**为 0 字节，并且文件位置指针会被定位到文件首。
  + `w+`：以**读写**的方式打开文件，如果文件不存在则创建，如果文件已存在则被**截断**为 0 字节，并且文件位置指针会被定位到文件首。
  + `a`：以**追加**的方式打开文件，如果文件不存在则创建，且文件位置指针会被定位到文件最后一个有效字符的后面（EOF，end of the file）。
  + `a+`：以**读和追加**的方式打开文件，如果文件不存在则创建，且读文件位置指针会被初始化到文件首，但是总是写入到最后一个有效字符的后面（EOF，end of the file）。

#### ④ 返回值：
FILE 是一个由标准库定义的结构体，各位童鞋不要企图通过手动修改结构体里的内容来实现文件的操作，一定要通过标准库函数来操作文件。

这个函数返回一个 FILE 类型的指针，它作为我们打开文件的凭据，后面所有对这个文件的操作都需要使用这个指针，而且使用之后一定不要忘记调用 fclose() 函数释放资源。

如果该函数返回了一个指向 NULL 的指针，则表示文件打开失败了，可以通过 errno 获取到具体失败的原因。

error 是什么呢？它是标准 C 中定义的一个整形值，用来表示上次发生的错误。大家可以在头文件中看看 errno 都定义了哪些值：

```shell
>$ vim /usr/include/asm-generic/errno.h
>$ vim /usr/include/asm-generic/errno-base.h
```

通常系统调用会给我们我返回一个整形值来表示是否出现了错误，当出现了错误的时候会设置 errno，通过 errno 我们就可以得知出现了什么错误了。

当然，直接给我们一个数字，我们自己再从头文件中查找这个数字表示的意义，然后再打印出来给用户看，似乎态麻烦了，没有什么简便的办法吗？

别担心，其实标准库已经为我们准备好专门的转换函数了：perror() 和 strerror()

+ **perror()**：会自动读取 errno 帮我们转换成对应的文字描述，并且将它们输出到标准错误流中。它的参数是一个字符串，用来让我们自定义一些错误消息给用户看，它的输出格式就是 我们给传递的参数：errno 转换的描述文字。
+ **strerror()**： 函数也会将 errno 转换为文字，不过它不会自动读取 errno 当前的值，需要我们把 errno 传递给它。它也不会帮我们输出到标准输出中，而是将转换完的字符串返回给我们。

如果大家是开发一个前台应用，一般可以使用 perror() 函数直接将错误输出给用户。

如果大家开发的是后台应用（如守护进程等），那么一般先使用 strerrno() 函数将 errno 转换为字符串，然后再把这个字符串传给日志系统记录下来。

**大家在使用 errno 这个全局变量的时候要导入 errno.h 头文件：**

```c
#include <errno.h>
```

**在使用 strerror() 函数时不要忘记导入 string.h 头文件，否则会报段错误！**

```c
#include <string.h>
```

其实现在的很多 *nix 系统中，errno 早已不是全局变量了，为了线程安全它已经变成了一个宏定义，这个我们在后面的博文中介绍线程的时候会讨论它。

```c
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    FILE *fp;
    fp = fopen("log","r");
    if (fp == NULL) {
        fprintf(stderr,"fopen() faild! errno = %d\n",errno); // errno已经被私有化,输出：fopen() faild! errno = 2
        perror("fopen"); // 输出：fopen: No such file or directory
        printf("%s\n",strerror(errno)); // 输出：No such file or directory
        exit(1);
    }else{
        fputs("ok!\n",stdout);
        fputs("OK\n",fp);
    }
    return 0;
}
```

结果如下：
```shell
fopen() faild! errno = 2
fopen: No such file or directory
No such file or directory
```

### 2.2 fclose()

#### ① 原型
```c
fclose - close a stream

#include <stdio.h>

int fclose(FILE *fp);
```

#### ② 功能
这个函数是与fopen()函数对应的，当我们使用完一个文件之后，需要调用fclose()函数释放相关的资源，否则会造成内存泄漏。当一个 FILE 指针被 fclose() 函数成功释放后，这个指针所指向的内容将不能再次被使用，如果需要再次打开文件还需要调用fopen()函数。


#### ③ 参数：

+ fp：fopen()函数的返回值作为参数传入即可。

#### ④ 返回值
如果流成功关闭，fclose 返回0，否则返回EOF（-1） 

### 2.3 fgetc()和fgets()

#### ① 原型
```c
// fgets - input of strings

#include <stdio.h>

int fgetc(FILE *stream);

char *fgets(char *s, int size, FILE *stream);
```

#### ② 功能
从输入流 stream 中读取一个字符串回填到 s 所指向的空间。

#### ③ 参数
> 参数是File类型的stream变量

这里出现了一个 stream 的概念，这个 stream 是什么呢，它被成为“流”，其实就是操作系统对于可以像文件一样操作的东西的一种抽象。它并非像自然界的小河流水一样潺潺细流，而通常是要么没有数据，要么一下子来一坨数据。当然 stream 也未必一定就是文件，比如系统为每个进程默认打开的三个 stream：stdin、stdout、stderr，它们本身就不是文件，就是与文件有着相同的操作方式，所以同样被抽象成了“流”。

这个函数并没有解决 gets()函数可能会导致的数组越界问题，而是通过牺牲了获取数据的正确性来保证程序不会出现数组越界的错误，实际上是掩盖了 gets() 的问题。

该函数遇到如下四种情况会返回：

+ 1.当读入的数据量达到 size - 1 时；
+ 2.当读取的字符遇到 \n 时；
+ 3.当读取的字符遇到 EOF 时；
+ 4.当读取遇到错误时；

并且它会在读取到的数据的最后面添加一个 `\0` 到 s 中。

#### ④ 返回值：
+ 成功时返回 s。
+ 返回NULL时表示出现了错误或者读到了strem 的末尾(EOF)。


### 2.4 fread()和fwrite()

#### ① 原型
```c
// fread, fwrite - binary stream input/output

#include <stdio.h>

size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);

size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
```

#### ② 功能
> 这两个函数使用得最频繁，用来读写 stream，通常是用来读写文件。

#### ④ 参数
+ ptr：fread() 将从 stream 中读取出来的数据回填到 ptr 所指向的位置；fwrite() 则将从 ptr 所只想的位置读取数据写入到 stream 中；
+ size：要读取的每个对象所占用的字节数；
+ nmemb：要读取出多少个对象；
+ stream：数据来源或去向；

#### ④ 返回值：

**注意这两个函数的返回值表示的是成功读（写）的对象的个数，而不是字节数！**

例如：

```c
read(buf, 1, 10, fp); // 读取 10 个对象，每个对象 1 个字节
read(buf, 10, 1, fp); // 读取 1 个对象，每个对象 10 个字节
```

当数据量充足的时候，这两种方式是没有区别的。

**但是！！**当数据量少于 size 个字节的整倍数时，第二种方法的的最后一个对象会读取失败。比如数据只有 45 个字节，那么第二种方法的返回值为 4，因为它只能成功读取 4 个对象。

所以通常第一种方式读写数据使用得比较普遍。

 

### 2.5 atoi()

#### ① 原型
```c
// atoi, atol, atoll, atoq - convert a string to an integer

#include <stdlib.h>

int atoi(const char *nptr);
long atol(const char *nptr);
long long atoll(const char *nptr);
long long atoq(const char *nptr);
```

#### ② 功能
atoi() 函数族在这里提一下，主要是为了下面的 printf() 函数族做一个铺垫。

这些函数的作用是方便的将一个字符串形式的数字转换为对应的数字类型的数字。

上面这句话可能有点坳口，给你看个例子就懂了，下面是伪代码。

```c
char *str = "123abc456";
int i = 0;
i = atoi(str);
```


i 的结果会变成 123。这些函数会转换一个字符串中地一个非有效数字前面的数字。

如果很不幸这个字符串中的第一个字符就不是一个有效数字时，那么它们会返回 0。


### 2.6 printf()

#### ① 原型
```c
// printf, fprintf,  sprintf,  snprintf - formatted output conversion

#include <stdio.h>

int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);
```

#### ② 功能
printf() 函数大家一定不会陌生了，应该从写 Hello World! 的时候就接触到了的吧，所以我也不多介绍了，主要介绍两个内容。

#### ③ 返回值
一个是面试常考的一个问题，用了这么久的 printf() 函数，大家有没有注意过它的返回值表示什么呢？

** printf() 的返回值表示成功打印的有效字符数量，不包括 \0。 **

另一个要说的就是刚才我们提到了 atoi() 函数族，它们负责将字符串转换为数字，那么有没有什么函数可以将数字转换为字符串呢，其实通过 sprintf() 或 snprintf() 就可以了。

有了这两个函数，不仅可以方便的将数字转换为字符串，还可以将多个字符串任意拼接为一个完整的字符串。

这里直接讲解一下 snprintf() 函数。

参数列表：
+ str：拼接之后的结果会回填到这个指针所指向的位置；
+ size：size - 1 为回填到 str 中的最大长度，数据超过这个长度的部分则会被舍弃，然后会在拼接的字符串的尾部追加 \0；
+ format：格式化字符串，用法与 printf() 相同，这里不再赘述；
+ ...：格式化字符串的参数，用法与 printf() 相同；

这个函数与 fputs() 一样，只是掩盖了 sprintf() 可能会导致的数组越界问题，通过牺牲数据的正确性来保证程序不会出现数组越界的错误。

### 2.7 scanf()

```c
// scanf,  fscanf, sscanf - input format conversion

#include <stdio.h>

int scanf(const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);
int sscanf(const char *str, const char *format, ...);
```


scanf() 函数族相信也不用过多的介绍了，这里唯一要强调的就是：**scanf() 函数支持多种格式化参数，唯独 %s 是不能安全使用的，可能会导致数组越界**，所以当需要接收用户输入的时候可以使用 fgets() 等函数来替代。

 

### 2.8 fseek()
#### ① 原型
```c
// fgetpos, fseek, fsetpos, ftell, rewind - reposition a stream

#include <stdio.h>

int fseek(FILE *stream, long offset, int whence);

long ftell(FILE *stream);

void rewind(FILE *stream);
```

#### ② 功能
fseek() 函数族的函数用来控制和获取文件位置指针所在的位置，从而能够使我们灵活的读写文件。

#### ③ 参数
介绍一下 fseek() 函数的参数列表：

+ stream：这个已经不需要多介绍了吧，就是准备修改文件位置指针的文件流；
+ offset：基于 whence 参数的偏移量；
+ whence：相对于文件的哪里；有三个宏定义可以作为它的参数：SEEK_SET（文件首）, SEEK_CUR（当前位置）, or SEEK_END（文件尾）；

#### ④ 返回值
成功返回 0；失败返回 -1，并且会设置 errno。

#### ⑤ 举例
单独看参数列表也许你还有所疑惑，那么我写点简单的伪代码作为例子：

```c
fseek(fp, -10, SEEK_CUR); // 从当前位置向前偏移10个字节。
fseek(fp, 2GB, SEEK_SET); // 可以制造一个空洞文件，如迅雷刚开始下载时产生的文件。
```

ftell() 函数以字节为单位获得文件指针的位置。

fseek(fp, 0, SEEK_END) + ftell() 可以计算出文件总字节大小。

还有一个值得大家注意的问题：

fseek() 和 ftell() 的参数和返回值使用了 long，所以取值范围为 -2GB ~ (2GB-1)，而 ftell() 只能表示 2G-1 之内的文件大小，所以可以使用 fseeko() 和 ftello() 函数替代它们，但它们只是方言（SUSv2, POSIX.1-2001.）。

由于这两个函数比较古老，所以设计的时候认为 +-2GB 的取值范围已经足够用了，而没有意识到科技发展如此迅速的今天，2GB 大小的文件已经完全不能满足实际的需求了。

rewind() 函数将文件位置指针移动到文件起始位置，相当于：

```c
(void) fseek(stream, 0L, SEEK_SET)
```

### 9.getline()
#### ① 原型
```c
// getline - delimited string input

#include <stdio.h>

ssize_t getline(char **lineptr, size_t *n, FILE *stream);

// Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

getline():
    Since glibc 2.10:
        _POSIX_C_SOURCE >= 200809L || _XOPEN_SOURCE >= 700
    Before glibc 2.10:
        _GNU_SOURCE
```

#### ② 功能
这个函数是一个非常好用的函数，它能帮助我们一次获取一行数据，而无论这个数据有多长。

#### ③参数
+ lineptr：一个一级指针的地址，它会将读取到的数据填写到一级指针指向的位置，并将>该位置回填到该参数中。指针初始必须置为NULL，该函数会根据指针是否为 NULL 来决定是否需要分配新的内存。
+ n：是由该函数回填的申请的内存缓冲区的总大小，长度初始必须置为0。

#### ③ 返回值
+ 成功则返回读取到的字节数
+ 失败返回-1

#### ③ 注意事项
虽然很好用，但是各位童鞋别高兴得太早了，该函数仅支持 GNU 标准，所以是方言，大家还是自己封装一个备用吧。

另外，想要使用这个函数必须在编译的时候指定 -D_GNU_SOURCE 参数：

```shell
$> gcc -D_GNU_SOURCE
```

当然如果不想在编译的时候添加参数，也可以在引用头文件之前 #define _GNU_SOURCE，只是比较丑陋而已。

还有一个办法，是在 makefile 中配置 CFLAGS += -D_GNU_SOURCE，这样即省去了编译时手动写参数的麻烦，也避免了代码中的丑陋。

### 10.fflush()

#### ① 原型
```c
// fflush - flush a stream

#include <stdio.h>

int fflush(FILE *stream);
```

#### ② 功能
fflush() 函数的作用是刷新缓冲区，提到这个函数就要讲讲缓冲区了。

缓冲区的作用是为了合并系统调用，在上面讲 STDIO 与 SYSIO 的区别时大家已经看到什么是合并系统调用了。

Linux 系统中有三种缓冲形式：无缓冲、行缓冲和全缓冲。

无缓冲：需要立刻输出时使用，例如 stderr；

行缓冲：遇到换行符时进行刷新、缓冲区满了的时候刷新、强制刷新(fflush())；而标准输出(stdout)是行缓冲，因为涉及到终端设备；

全缓冲：只有缓冲区满了的时候和强制刷新(fflush())时才会刷新，这是 Linux 默认的缓冲模式，但终端设备除外，终端设备使用行缓冲模式；

当数据被放入缓冲区的时候是不会通过系统调用(read()、write())送到内核中的，只有缓冲区被刷新的时候数据才会通过系统调用进入内核。而刷新缓冲区就是 fflush() 函数的作用。

fflush() 的参数是具体要刷新的流，当参数为 NULL 时会刷新所有的输出流。