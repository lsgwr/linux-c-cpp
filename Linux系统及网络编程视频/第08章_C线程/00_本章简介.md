# 第9章 c线程

## 1. 快速认识下c线程

代码演示：

## 2. 为什么会有线程？

在上世纪60年代，也就是操作系统刚问世不久时，那个时候的OS只有进程没有线程，直到到了80年代才开始有了线程这个东西。

为什么有线程这个东西呢？  
主要是人们开始发现，进程有缺点，为了弥补进程的缺点，就发明了线程这个东西，需要注意的是，我说的是弥补而不是替代，也就是说线程不会把进程给干掉，线程也是基于进程而实现的，是没办法干掉进程的。

## 3. 进程的缺点

我们在前面的课程说过，为了让每个进程有一个安全的独立进程空间，OS使用了虚拟内存机制，通过虚拟内存机制，能够让每一个进程都有完全独立的进程空间。

这种独立的进程空间最大的优点就是，可以很好地保证每一个进程的安全，不被其它进程所攻击或者干扰，但是突出的优点往往又会导致另外的缺点。

拥有独立进程空间的进程有两大明显的缺点

+ （1）进程间切换的计算机资源开销很大，切换效率非常低
+ （2）进程间数据共享的开销也很大

### 3.1 进程间切换的计算机资源开销很大，切换效率非常低

OS是通过虚拟内存机制来实现进程空间独立的，进程在并发运行时需要相互间的切换，切换时必然需要涉及虚拟内存机制的控制，但是虚拟内存机制比较复杂，所以在进行进程间切换时，会耗费高昂的cpu、缓存(cache)、内存等计算机资源，也非常耗费切换时间。

总之，进程切换的开销很大，有关进程间切换的开销问题，目前因为课程定位问题，我们目前只能以这种笼统的方式来解释，不过也确实没有深入介绍的必要，对于大家来说，你只需要清楚进程切换时的计算机资源开销是很大就行。

### 3.2 进程间数据共享的开销也很大

当程序涉及多进程时，往往会涉及到进程间的通信，但是由于进程空间的独立性，OS提供了各种各样的通信机制

这些通信机制共同原理就是，通过OS来转发进程间的数据，但是调用OS提供的这些通信机制的函数时，这些OS函数的运行也是需要消耗相当cpu、内存等计算机资源的，同时也很耗费时间。

因此，对于我们有OS的计算机来说，虽然进程是必不可少的，但是进程确又不能太多，进程太多会导致计算机资源被剧烈消耗，此时你会发现你的计算机非常的卡。

## 4. 因为进程的缺点，使得早期只有进程的OS存在着非常大的问题

在早期，当OS只有进程时，应用程序通过创建子进程来得到多进程的目的大致有两个：

+ （1）目的1：创建子进程，执行新程序

+ （2）目的2：创建子进程得到多进程，通过多进程并发实现多线任务
  + 1）同时阻塞的读鼠标和键盘时，如果单线的话会想互影响，需要两线任务来实现。
  + 2）读写管道时，读操作是阻塞的，为了避免读操作影响写操作，也需要两线任务同时进行。
  + 3）等等：多线任务的例子很多

对于第一种目的，执行新程序时必须创建子进程，这个无法逃避的。

但是对于第二种目的来说，如果使用多进程来实现就存在巨大的问题，因为几乎所有的程序都涉及多线任务的操作，而且好些程序往往都是十几个任务以上，如果此时使用多进程来实现多线任务的，这就大致大量进程的产生。

比如计算机运行了100个程序，假设每个程序平均10多个任务，如果全部采用多进程来实现，计算机最终要运行的进程就多达上100个。

所以在早期使用多进程来实现程序的多线任务时，往往导致计算机进程数量暴增，而进程切换和进程间通信的计算机资源开销又很大，因此往往导致计算机非常卡顿，程序的运行效率非常低。

当人们认识到进程缺点所带来的巨大问题后，大家就开始思考，能不能使用另一种方式来实现程序的“多线任务”，而不是使用多进程来实现，到了上世纪80年代人们就发明了线程这个东西，以弥补多进程实现多线任务的缺点。

## 5. 线程为什么能弥补进程的缺点

首先我们需要明白，线程与进程一样，线程和进程会被OS统一调度，所以所有的线程和进程都是一起并发运行的，如果线程不是并发的，是不可能实现程序的多线任务的。

有了线程以后，凡是程序涉及到多线任务时，都使用多线程来实现，使用多线程来实现时，线程间的切换和数据通信的开销非常低，正因为开销非常低，因此线程还有另一个名称，叫“轻量级的进程”。

总结的讲，说白了线程就是为了多线任务而生的，多线程的多线二字，不就是多线任务的多线二字吗。

疑问：使用线程来实现时，线程也需要切换和通信，为什么线程的切换和通信开销就很低呢？

### 5.1 为什么线程切换的开销很低

使用多进程来实现程序的多线任务，多线并发运行时，涉及到的是进程间的切换，我们前面就说过，进程间切换时开销非常大。

但是使用多线程来实现多线任务时，由于线程本质上它只是程序（进程）的一个函数，只不过线程函数与普通函数的区别是，普通函数时单线的运行关系，而线程函数被注册为线程后，是多线并发运行。图：

对于普通函数来说，只有当相互调动时才会涉及函数间的切换，但是对于线程函数来说，只要运行的时间片到了就会切换，但是不管是那种函数间的切换，进程自己函数的切换只是进程内部的事情，不涉及进程间切换，就省去了进程间切换的巨大开销。图：

如果是不同进程的线程之间需要切换的话，还是会涉及到进程间的切换了，但是不管怎们说，线程的出现，至少为程序内部多线任务之间的切换，省去了大笔的进程切换所导致“资源开销”。

疑问：线程切换不一样需要开销？
刚说过，线程的切换其实就是函数间的切换，函数切换当然也需要开销，但是这些开销相比进程间切换的开销来说，已经非常小了。

### 5.2 为什么线程间数据通信的开销很低

线程的本质就是函数，请问大家函数之间如果想要数据共享（通信）的话，应该怎么办？

函数间通信有两种方式：

+ （1）具有相互调用关系函数来说
  使用函数传参来通信。

+ （2）对于没有调用关系的函数来说
  使用全局变量来通信。
  A函数 ————> 全局变量 ————> B函数

  所以说全局变量的作用是什么？
  就是用来实现无调用关系的函数间通信的。

  进程中所有的线程函数除了相互并发运行外，没有调用关系，所以线程函数间想要数据共享的话，就使用全局变量来通信。

  从这里可以看出，进程内部的线程间进行数据共享非常容易，使用全局变量即可，根本不需要调用什么OS提供的通信机制，所以线程间通信的开销自然就非常的低。

### 5.3 是不是有了线程后，进程就不需要了

有关这个问题，我们在前面就已经回答过，线程是不可能完全替代掉进程的，只有在多线任务时会替代进程，但是运行新程序的时，我们还是必须创建子进程。

本小节再次提这个问题，是想重点会回答一下，为什么线程不可能完全替换掉进程。

通过前面的讲解，我们知道线程的本质是函数，函数运行需要内存空间，这个内存空间怎么来，事实上线程运行的内存空间就是进程的内存空间，因此线程运行时必须依赖于进程的存在，如果没有进程所提供的内存空间这个资源，线程根本无法运行。图：

换句话说，线程作为函数，只是进程的一个部分而已，线程是不可能脱离进程而独立存在。

所以同一个进程中的所有线程，都是运行在相同的进程空间中的，换句话说同一个进程中所有线程共相同的进程空间。

这里请大家再思考下，为什么程序（进程）的函数能够通过全局变量来通信，就是因为全局变量、函数等全部都在同一个进程空间中，既然进程空间是大家共享的，那么所有的函数，自然就能共享访问在共享空间中所开辟出来的全局变量。

对于进程中的所有函数来说（包括线程函数)，进程中几乎所有的资源都是共享的，比如打开的文件描述，所有可以被调用的子函数，进程的当前工作目录，进程uid、gid，进程PID等等。

### 5.4 线程自己独立的属性

进程中的所有线程会共享进程提供资源（全局变量、工作目录、打开的文件描述符、子函数等等），但是每个线程作为一个单独的执行体，也有属于自己的独立的东西。

+ （1）每个线程拥有自己独立的线程ID（TID）
+ （2）每个线程有独立的切换状态
  + 1）在切换时，当前线程被中断的那条指令的地址
  + 2）线程切换时相关的运行状态
    当线程切换时，必须保存以上信息，以便切换回来后还原现场，从中断处继续运行。
    这就好比我正在工作，突然有人来找我，此时我么就被中断了，我就需要保存好我的工作现场，等我回来时再还原工作现场，以便接着做。

+ （3）有自己独立的函数栈
  其实每一个函数都有自己的函数栈，所有的函数栈都开辟于进程空间的进程栈。

  函数栈的作用就是用来保存函数局部变量的，既然所有的线程函数都有自己的独立的函数栈，自然就有自己独立的局部变量
  
  线程函数的函数栈，我们往往也称为线程栈。

+ （4）自己独立的错误号
  线程函数的错误号是独立的，所以线程函数出错时，错误号并不是通过设置errno实现的，而是直接将错误号返回。

+ （5）每一个线程有自己独立的信号屏蔽字和未决信号集
  后面还会在介绍。

+ （6）每个线程有自己独立的tack_struct结构体

  我们说进程在运行的过程中，OS会为每个进程开辟一个task_struct结构体变量用于存放进程所涉及到的各种管理信息，同样的为了管理线程，也会为线程开辟一个task_struct变量，只不过适用于存放线程的管理信息的。

## 6. 我们自己写的程序，什么时候使用多线程和多进程

### 6.1 线程

程序涉及多线任务时，使用线程。

### 6.2 进程

程序涉及到运行新程序时，必须使用多进程，不过一般来说，如果不是大型软件和框架的话，我们的程序并不需要执行新程序。

创建子进程执行新程序，大多都是OS操心的事，比如通过命令行或者图形界面启动程序，此时就涉及到要运行一个新的程序，根据我们进程控制章节的学习，父进程（命令行、图形界面）就会创建子进程并加载执行新程序。